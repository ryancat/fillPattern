(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("fillPattern", [], factory);
	else if(typeof exports === 'object')
		exports["fillPattern"] = factory();
	else
		root["fillPattern"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/fillPattern.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/fillPattern.ts":
/*!****************************!*\
  !*** ./src/fillPattern.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// my awesom library
var types_1 = __webpack_require__(/*! ./types */ "./src/types.ts");
var util_1 = __importDefault(__webpack_require__(/*! ./util */ "./src/util.ts"));
// import svgRenderer from './renderers/svg'
var canvas_1 = __importDefault(__webpack_require__(/*! ./renderers/canvas */ "./src/renderers/canvas.ts"));
var fillPatternState_1 = __importDefault(__webpack_require__(/*! ./fillPatternState */ "./src/fillPatternState.ts"));
var Base_1 = __importDefault(__webpack_require__(/*! ./textures/Base */ "./src/textures/Base.ts"));
var Line_1 = __importDefault(__webpack_require__(/*! ./textures/Line */ "./src/textures/Line.ts"));
/***** Util functions *****/
/**
 * Get the hash for given fill pattern config.
 * The hash result is used to decide if given config is in cached patterns.
 * @param patternConfig fill pattern config
 * @returns string hash value
 */
function getHash(patternConfig, rendererType) {
    return rendererType + "-" + JSON.stringify(patternConfig);
}
var fillPattern = {
    RendererType: types_1.RendererType,
    TextureModeType: types_1.TextureModeType,
    loadTexture: function (texture) {
        if (!fillPatternState_1.default.textureMap[texture.name]) {
            // util.applyMixins(texture, [BaseTexture])
            // util.mixin(texture, new BaseTexture())
            fillPatternState_1.default.textureMap[texture.name] = new Base_1.default(texture);
        }
        else {
            throw new Error("Duplicated texture name: " + texture.name);
        }
    },
    /**
     * Get texture from the pattern config
     * @param patternConfig fill pattern config
     * @returns canvas pattern that can be used for fill instruction
     */
    getTexture: function (patternConfig, rendererType) {
        var hashKey = getHash(patternConfig, rendererType);
        var renderer;
        switch (rendererType) {
            case types_1.RendererType.Canvas:
                renderer = canvas_1.default;
                break;
            // case RendererType.SVG:
            //   renderer = svgRenderer
            //   break
            default:
                throw new Error("Unknown renderer type: " + rendererType);
        }
        if (!fillPatternState_1.default.fillPatternCache[hashKey]) {
            var texture = fillPatternState_1.default.textureMap[patternConfig.name];
            if (!texture) {
                throw new Error("No such texture to load: " + patternConfig.name + "\n Please load the texture first!");
            }
            // Draw on the texture recursively and get the expected result
            var textureElement = renderer.getInitTexture(patternConfig.backgroundColor);
            if (!texture.draw) {
                throw new Error("Texture has no pre-defined draw function: " + texture.name);
            }
            texture.draw(textureElement, renderer, {
                mode: patternConfig.mode,
            });
            fillPatternState_1.default.fillPatternCache[hashKey] = textureElement;
        }
        return fillPatternState_1.default.fillPatternCache[hashKey];
    },
    textureModeType: {
        Light: types_1.TextureModeType.Light,
        Medium: types_1.TextureModeType.Medium,
        Heavy: types_1.TextureModeType.Heavy,
    },
};
// Need to load all built-in textures
util_1.default.loadTexture(new Line_1.default());
exports.default = fillPattern;


/***/ }),

/***/ "./src/fillPatternState.ts":
/*!*********************************!*\
  !*** ./src/fillPatternState.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var fillPatternCache = {};
var textureMap = {};
exports.default = {
    fillPatternCache: fillPatternCache,
    textureMap: textureMap,
};


/***/ }),

/***/ "./src/renderers/canvas.ts":
/*!*********************************!*\
  !*** ./src/renderers/canvas.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __importDefault(__webpack_require__(/*! ../util */ "./src/util.ts"));
var canvasRenderer = {
    getInitTexture: function (backgroundColor) {
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        if (!context) {
            throw new Error('canvas 2d context is not supported in this browser');
        }
        canvas.width = 2;
        canvas.height = 2;
        context.fillStyle = backgroundColor || 'transparent';
        context.fillRect(0, 0, 2, 2);
        return canvas;
    },
    drawLineTexture: function (canvasTextureElement, textureConfig) {
        if (!canvasTextureElement) {
            throw new Error('No canvas texture element to draw texture with');
        }
        var distance = textureConfig.distance;
        var lineWidth = textureConfig.thickness;
        var rotation = textureConfig.rotation;
        var dimensions = textureConfig.dimensions;
        if (!dimensions) {
            throw new Error('Line texture requires dimensions config');
        }
        var width = dimensions.width;
        var height = dimensions.height;
        // const isFill = textureConfig.isFill
        // const isStroke = textureConfig.isStroke
        var minY = height / 2 - distance;
        var maxY = height / 2 + distance;
        var minX = 0.5 * (width - Math.sqrt(width * width + height * height));
        var maxX = 0.5 * (width + Math.sqrt(width * width + height * height));
        var offsetX = (textureConfig.offsetX || 0) % width;
        var offsetY = (textureConfig.offsetY || 0) % height;
        var textureCanvas = document.createElement('canvas');
        var textureCtx = textureCanvas.getContext('2d');
        if (!textureCtx) {
            throw new Error('canvas 2d context is not supported in this browser');
        }
        textureCanvas.width = Math.floor(width);
        textureCanvas.height = Math.floor(height);
        // Start to draw lines
        // if (isFill) {
        //   textureCtx.fillStyle = config.color
        // }
        // if (isStroke) {
        //   textureCtx.strokeStyle = config.color
        // }
        textureCtx.strokeStyle = textureConfig.color;
        // Rotate texture canvas
        canvasRenderer.rotate(textureCanvas, rotation);
        textureCtx.lineWidth = lineWidth;
        textureCtx.beginPath();
        var y = minY;
        while (y <= maxY) {
            textureCtx.moveTo(minX + offsetX, y + offsetY);
            textureCtx.lineTo(maxX + offsetX, y + offsetY);
            // The canvas will be round down to full pixel dimension, while the calculation
            // assumes we are using the original larger dimensions in fraction of a pixel.
            // This will compensate that.
            y += distance - 0.25;
        }
        textureCtx.stroke();
        // if (isStroke) {
        //   textureCtx.stroke()
        // }
        // if (isFill) {
        //   textureCtx.fill()
        // }
        canvasRenderer.combineTextures(canvasTextureElement, textureCanvas);
    },
    rotate: function (canvasElement, angle, originPosition) {
        var context = canvasElement.getContext('2d');
        if (!context) {
            throw new Error('canvas 2d context is not supported in this browser');
        }
        var width = canvasElement.width;
        var height = canvasElement.height;
        var originX = width / 2;
        var originY = height / 2;
        // Rotate texture canvas
        if (originPosition) {
            originX = originPosition.x;
            originY = originPosition.y;
        }
        context.translate(originX, originY);
        context.rotate(angle);
        context.translate(-originX, -originY);
    },
    combineTextures: function (destinationCanvasTextureElement, sourceCanvasTextureElement) {
        var context = destinationCanvasTextureElement.getContext('2d');
        if (!context) {
            throw new Error('canvas 2d context is not supported in this browser');
        }
        var finalCanvasWidth = destinationCanvasTextureElement.width;
        var finalCanvasHeight = destinationCanvasTextureElement.height;
        var finalCanvas;
        var finalContext;
        context.save();
        // In case we have multiple patterns, we need to use a texture canvas the size of the
        // least common multiplier of width and height of all of them
        finalCanvasWidth = util_1.default.lcm(finalCanvasWidth, sourceCanvasTextureElement.width);
        finalCanvasHeight = util_1.default.lcm(finalCanvasHeight, sourceCanvasTextureElement.height);
        if (finalCanvasWidth === destinationCanvasTextureElement.width &&
            finalCanvasHeight === destinationCanvasTextureElement.height) {
            // the canvas is still fine to use
            context.fillStyle = context.createPattern(sourceCanvasTextureElement, 'repeat');
            context.fillRect(0, 0, finalCanvasWidth, finalCanvasHeight);
        }
        else {
            // we need to update the dimension for the canvas
            finalCanvas = document.createElement('canvas');
            finalCanvas.width = finalCanvasWidth;
            finalCanvas.height = finalCanvasHeight;
            finalContext = finalCanvas.getContext('2d');
            if (!finalContext) {
                throw new Error('canvas 2d context is not supported in this browser');
            }
            // First fill the original texture
            finalContext.fillStyle = finalContext.createPattern(destinationCanvasTextureElement, 'repeat');
            finalContext.fillRect(0, 0, finalCanvasWidth, finalCanvasHeight);
            // Then fill the new texture
            finalContext.fillStyle = finalContext.createPattern(sourceCanvasTextureElement, 'repeat');
            finalContext.fillRect(0, 0, finalCanvasWidth, finalCanvasHeight);
            // Update canvas and reset it to final canvas
            destinationCanvasTextureElement.width = finalCanvasWidth;
            destinationCanvasTextureElement.height = finalCanvasHeight;
            context.clearRect(0, 0, finalCanvasWidth, finalCanvasHeight);
            context.drawImage(finalCanvas, 0, 0);
        }
        context.restore();
    },
    // TODO: In SVG case, the source texture is actually just a svg pattern element
    // // We need to make some changes here to get this part working
    getDataURL: function (canvasTextureElement) { return canvasTextureElement.toDataURL(); },
    getTextureSize: function (canvasTextureElement) {
        return {
            width: canvasTextureElement.width,
            height: canvasTextureElement.height,
        };
    },
};
exports.default = canvasRenderer;


/***/ }),

/***/ "./src/textures/Base.ts":
/*!******************************!*\
  !*** ./src/textures/Base.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = __webpack_require__(/*! ../types */ "./src/types.ts");
var fillPatternState_1 = __importDefault(__webpack_require__(/*! ../fillPatternState */ "./src/fillPatternState.ts"));
var BaseTexture = /** @class */ (function () {
    function BaseTexture(textureOptions) {
        this.name = 'baseTexture';
        this.mode = {
            // TODO: How to use enums for the default texture config name?
            default: {
                thickness: 1,
                distance: 3,
                rotation: 0,
                color: '#000000',
                offsetX: 0,
                offsetY: 0,
            },
        };
        Object.assign(this, textureOptions);
    }
    BaseTexture.prototype.draw = function (textureElement, renderer, drawConfig) {
        var mode = drawConfig.mode, config = drawConfig.config;
        var textureConfigs = this.mode[mode || types_1.TextureModeType.Default];
        if (!Array.isArray(textureConfigs)) {
            textureConfigs = [textureConfigs];
        }
        textureConfigs.forEach(function (configDetails) {
            var name = configDetails.name, detailConfigs = __rest(configDetails, ["name"]);
            if (!name) {
                // The pattern mode configs may contain any fill pattern as its children
                // layers. If it does so, it need to include the pattern name in the config
                // details. For basic fill patterns like line, circle or square, they need
                // to override draw function to draw by themselves, hence it should never
                // hit this condition here.
                throw new Error("Do not know how to draw this config: " + name);
            }
            // The config has a pattern name, which means it's composed by
            // other patterns
            var childTexture = fillPatternState_1.default.textureMap[name];
            if (!childTexture) {
                throw new Error("No such texture exist: " + name);
            }
            if (!childTexture.draw) {
                throw new Error("Cannot draw texture: " + name);
            }
            childTexture.draw(textureElement, renderer, {
                mode: mode,
                // We got some problem here
                // Should the config pass down to the grand children?
                config: Object.assign({}, detailConfigs, config),
            });
        });
    };
    return BaseTexture;
}());
exports.default = BaseTexture;


/***/ }),

/***/ "./src/textures/Line.ts":
/*!******************************!*\
  !*** ./src/textures/Line.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = __webpack_require__(/*! ../types */ "./src/types.ts");
var base_1 = __importDefault(__webpack_require__(/*! ./base */ "./src/textures/base.ts"));
var DEFAULT_PATTERN_SIZE = 10;
function calculateDimensions(distance, rotation) {
    var width;
    var height;
    rotation = rotation % Math.PI;
    if (rotation === 0) {
        width = DEFAULT_PATTERN_SIZE;
        height = distance;
    }
    else if (rotation === Math.PI * 0.5) {
        width = distance;
        height = DEFAULT_PATTERN_SIZE;
    }
    else {
        width = distance / Math.sin(rotation);
        height = distance / Math.abs(Math.cos(rotation));
    }
    return {
        height: height,
        width: width,
    };
}
var lightModeTexture = {
    color: '#000000',
    distance: 4,
    rotation: 0,
    thickness: 1,
};
var mediumModeTexture = {
    color: '#000000',
    distance: 4,
    rotation: 0,
    thickness: 2,
};
var heavyModeTexture = {
    color: '#000000',
    distance: 4,
    rotation: 0,
    thickness: 3,
};
var LineTexture = /** @class */ (function (_super) {
    __extends(LineTexture, _super);
    function LineTexture() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'line';
        _this.mode = {
            // TODO: How to use enums for the default texture config name?
            default: mediumModeTexture,
            light: lightModeTexture,
            medium: mediumModeTexture,
            heavy: heavyModeTexture,
        };
        return _this;
    }
    LineTexture.prototype.draw = function (textureElement, renderer, drawConfig) {
        var mode = drawConfig.mode, config = drawConfig.config;
        var textureConfig = Object.assign({}, 
        // TODO: default to the medium mode, but it should really be some fallback mode
        this.mode[mode || types_1.TextureModeType.Medium], config);
        textureConfig.dimensions = textureConfig.dimensions ||
            calculateDimensions(textureConfig.distance, textureConfig.rotation);
        renderer.drawLineTexture(textureElement, textureConfig);
    };
    return LineTexture;
}(base_1.default));
exports.default = LineTexture;


/***/ }),

/***/ "./src/textures/base.ts":
/*!******************************!*\
  !*** ./src/textures/base.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = __webpack_require__(/*! ../types */ "./src/types.ts");
var fillPatternState_1 = __importDefault(__webpack_require__(/*! ../fillPatternState */ "./src/fillPatternState.ts"));
var BaseTexture = /** @class */ (function () {
    function BaseTexture(textureOptions) {
        this.name = 'baseTexture';
        this.mode = {
            // TODO: How to use enums for the default texture config name?
            default: {
                thickness: 1,
                distance: 3,
                rotation: 0,
                color: '#000000',
                offsetX: 0,
                offsetY: 0,
            },
        };
        Object.assign(this, textureOptions);
    }
    BaseTexture.prototype.draw = function (textureElement, renderer, drawConfig) {
        var mode = drawConfig.mode, config = drawConfig.config;
        var textureConfigs = this.mode[mode || types_1.TextureModeType.Default];
        if (!Array.isArray(textureConfigs)) {
            textureConfigs = [textureConfigs];
        }
        textureConfigs.forEach(function (configDetails) {
            var name = configDetails.name, detailConfigs = __rest(configDetails, ["name"]);
            if (!name) {
                // The pattern mode configs may contain any fill pattern as its children
                // layers. If it does so, it need to include the pattern name in the config
                // details. For basic fill patterns like line, circle or square, they need
                // to override draw function to draw by themselves, hence it should never
                // hit this condition here.
                throw new Error("Do not know how to draw this config: " + name);
            }
            // The config has a pattern name, which means it's composed by
            // other patterns
            var childTexture = fillPatternState_1.default.textureMap[name];
            if (!childTexture) {
                throw new Error("No such texture exist: " + name);
            }
            if (!childTexture.draw) {
                throw new Error("Cannot draw texture: " + name);
            }
            childTexture.draw(textureElement, renderer, {
                mode: mode,
                // We got some problem here
                // Should the config pass down to the grand children?
                config: Object.assign({}, detailConfigs, config),
            });
        });
    };
    return BaseTexture;
}());
exports.default = BaseTexture;


/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/***** Enums *****/
var RendererType;
(function (RendererType) {
    RendererType[RendererType["Canvas"] = 0] = "Canvas";
    RendererType[RendererType["SVG"] = 1] = "SVG";
})(RendererType = exports.RendererType || (exports.RendererType = {}));
var TextureModeType;
(function (TextureModeType) {
    TextureModeType[TextureModeType["Light"] = 0] = "Light";
    TextureModeType[TextureModeType["Medium"] = 1] = "Medium";
    TextureModeType[TextureModeType["Heavy"] = 2] = "Heavy";
    TextureModeType[TextureModeType["Default"] = 3] = "Default";
})(TextureModeType = exports.TextureModeType || (exports.TextureModeType = {}));


/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fillPatternState_1 = __importDefault(__webpack_require__(/*! ./fillPatternState */ "./src/fillPatternState.ts"));
var gcdCache = {};
var util = {
    gcd: function (number1, number2) {
        if (typeof number1 !== 'number' || typeof number2 !== 'number' ||
            (Number.isNaN || isNaN)(number1) || (Number.isNaN || isNaN)(number2) ||
            number1 <= 0 || number2 <= 0) {
            return -1;
        }
        var key1 = number1 + '-' + number2;
        var key2 = number2 + '-' + number1;
        if (gcdCache[key1]) {
            return gcdCache[key1];
        }
        if (number1 !== number2) {
            if (number1 > number2) {
                number1 = number1 - number2;
            }
            else {
                number2 = number2 - number1;
            }
            gcdCache[key1] = util.gcd(number1, number2);
            gcdCache[key2] = gcdCache[key1];
            return gcdCache[key1];
        }
        else {
            gcdCache[key1] = number1;
            return number1;
        }
    },
    lcm: function (number1, number2) {
        if (typeof number1 !== 'number' || typeof number2 !== 'number' ||
            (Number.isNaN || isNaN)(number1) || (Number.isNaN || isNaN)(number2) ||
            number1 <= 0 || number2 <= 0) {
            return -1;
        }
        return number1 * number2 / util.gcd(number1, number2);
    },
    mixin: function (destinationObj, sourceObj) {
        var key;
        for (key in sourceObj) {
            if (sourceObj.hasOwnProperty(key)) {
                if (!destinationObj.hasOwnProperty(key)) {
                    destinationObj[key] = sourceObj[key];
                }
            }
        }
    },
    applyMixins: function (derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            });
        });
    },
    loadTexture: function (texture) {
        if (!fillPatternState_1.default.textureMap[texture.name]) {
            // util.applyMixins(texture, [BaseTexture])
            // util.mixin(texture, new BaseTexture())
            fillPatternState_1.default.textureMap[texture.name] = texture;
        }
        else {
            throw new Error("Duplicated texture name: " + texture.name);
        }
    },
};
exports.default = util;


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWxsUGF0dGVybi93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vZmlsbFBhdHRlcm4vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZmlsbFBhdHRlcm4vLi9zcmMvZmlsbFBhdHRlcm4udHMiLCJ3ZWJwYWNrOi8vZmlsbFBhdHRlcm4vLi9zcmMvZmlsbFBhdHRlcm5TdGF0ZS50cyIsIndlYnBhY2s6Ly9maWxsUGF0dGVybi8uL3NyYy9yZW5kZXJlcnMvY2FudmFzLnRzIiwid2VicGFjazovL2ZpbGxQYXR0ZXJuLy4vc3JjL3RleHR1cmVzL0Jhc2UudHMiLCJ3ZWJwYWNrOi8vZmlsbFBhdHRlcm4vLi9zcmMvdGV4dHVyZXMvTGluZS50cyIsIndlYnBhY2s6Ly9maWxsUGF0dGVybi8uL3NyYy90ZXh0dXJlcy9iYXNlLnRzIiwid2VicGFjazovL2ZpbGxQYXR0ZXJuLy4vc3JjL3R5cGVzLnRzIiwid2VicGFjazovL2ZpbGxQYXR0ZXJuLy4vc3JjL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hB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LENBQUMsOEJBQTRCLE9BQU8sQ0FBQyxJQUFNLENBQUM7U0FDNUQ7SUFDSCxDQUFDO0NBQ0Y7QUFFRCxrQkFBZSxJQUFJIiwiZmlsZSI6ImZpbGxQYXR0ZXJuLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiZmlsbFBhdHRlcm5cIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZmlsbFBhdHRlcm5cIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiZmlsbFBhdHRlcm5cIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2ZpbGxQYXR0ZXJuLnRzXCIpO1xuIiwiLy8gbXkgYXdlc29tIGxpYnJhcnlcbmltcG9ydCB7SVBhdHRlcm5Db25maWcsIElSZW5kZXJlciwgVGV4dHVyZUVsZW1lbnQsIFJlbmRlcmVyVHlwZSwgSVRleHR1cmUsIFRleHR1cmVNb2RlVHlwZX0gZnJvbSAnLi90eXBlcydcbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCdcbi8vIGltcG9ydCBzdmdSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVycy9zdmcnXG5pbXBvcnQgY2FudmFzUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlcnMvY2FudmFzJ1xuaW1wb3J0IGZpbGxQYXR0ZXJuU3RhdGUgZnJvbSAnLi9maWxsUGF0dGVyblN0YXRlJ1xuaW1wb3J0IEJhc2VUZXh0dXJlIGZyb20gJy4vdGV4dHVyZXMvQmFzZSdcbmltcG9ydCBMaW5lVGV4dHVyZSBmcm9tICcuL3RleHR1cmVzL0xpbmUnXG5cbi8qKioqKiBVdGlsIGZ1bmN0aW9ucyAqKioqKi9cbi8qKlxuICogR2V0IHRoZSBoYXNoIGZvciBnaXZlbiBmaWxsIHBhdHRlcm4gY29uZmlnLlxuICogVGhlIGhhc2ggcmVzdWx0IGlzIHVzZWQgdG8gZGVjaWRlIGlmIGdpdmVuIGNvbmZpZyBpcyBpbiBjYWNoZWQgcGF0dGVybnMuXG4gKiBAcGFyYW0gcGF0dGVybkNvbmZpZyBmaWxsIHBhdHRlcm4gY29uZmlnXG4gKiBAcmV0dXJucyBzdHJpbmcgaGFzaCB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRIYXNoKHBhdHRlcm5Db25maWc6IElQYXR0ZXJuQ29uZmlnLCByZW5kZXJlclR5cGU6IFJlbmRlcmVyVHlwZSk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtyZW5kZXJlclR5cGV9LSR7SlNPTi5zdHJpbmdpZnkocGF0dGVybkNvbmZpZyl9YFxufVxuXG5jb25zdCBmaWxsUGF0dGVybiA9IHtcbiAgUmVuZGVyZXJUeXBlLFxuXG4gIFRleHR1cmVNb2RlVHlwZSxcblxuICBsb2FkVGV4dHVyZTogKHRleHR1cmU6IElUZXh0dXJlKTogdm9pZCA9PiB7XG4gICAgaWYgKCFmaWxsUGF0dGVyblN0YXRlLnRleHR1cmVNYXBbdGV4dHVyZS5uYW1lXSkge1xuICAgICAgLy8gdXRpbC5hcHBseU1peGlucyh0ZXh0dXJlLCBbQmFzZVRleHR1cmVdKVxuICAgICAgLy8gdXRpbC5taXhpbih0ZXh0dXJlLCBuZXcgQmFzZVRleHR1cmUoKSlcblxuICAgICAgZmlsbFBhdHRlcm5TdGF0ZS50ZXh0dXJlTWFwW3RleHR1cmUubmFtZV0gPSBuZXcgQmFzZVRleHR1cmUodGV4dHVyZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGVkIHRleHR1cmUgbmFtZTogJHt0ZXh0dXJlLm5hbWV9YClcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0ZXh0dXJlIGZyb20gdGhlIHBhdHRlcm4gY29uZmlnXG4gICAqIEBwYXJhbSBwYXR0ZXJuQ29uZmlnIGZpbGwgcGF0dGVybiBjb25maWdcbiAgICogQHJldHVybnMgY2FudmFzIHBhdHRlcm4gdGhhdCBjYW4gYmUgdXNlZCBmb3IgZmlsbCBpbnN0cnVjdGlvblxuICAgKi9cbiAgZ2V0VGV4dHVyZTogKHBhdHRlcm5Db25maWc6IElQYXR0ZXJuQ29uZmlnLCByZW5kZXJlclR5cGU6IFJlbmRlcmVyVHlwZSk6IFRleHR1cmVFbGVtZW50ID0+IHtcbiAgICBjb25zdCBoYXNoS2V5OiBzdHJpbmcgPSBnZXRIYXNoKHBhdHRlcm5Db25maWcsIHJlbmRlcmVyVHlwZSlcbiAgICBsZXQgcmVuZGVyZXJcblxuICAgIHN3aXRjaCAocmVuZGVyZXJUeXBlKSB7XG4gICAgICBjYXNlIFJlbmRlcmVyVHlwZS5DYW52YXM6XG4gICAgICAgIHJlbmRlcmVyID0gY2FudmFzUmVuZGVyZXJcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gY2FzZSBSZW5kZXJlclR5cGUuU1ZHOlxuICAgICAgLy8gICByZW5kZXJlciA9IHN2Z1JlbmRlcmVyXG4gICAgICAvLyAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biByZW5kZXJlciB0eXBlOiAke3JlbmRlcmVyVHlwZX1gKVxuICAgIH1cblxuICAgIGlmICghZmlsbFBhdHRlcm5TdGF0ZS5maWxsUGF0dGVybkNhY2hlW2hhc2hLZXldKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlID0gZmlsbFBhdHRlcm5TdGF0ZS50ZXh0dXJlTWFwW3BhdHRlcm5Db25maWcubmFtZV1cblxuICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCB0ZXh0dXJlIHRvIGxvYWQ6ICR7cGF0dGVybkNvbmZpZy5uYW1lfVxcbiBQbGVhc2UgbG9hZCB0aGUgdGV4dHVyZSBmaXJzdCFgKVxuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IG9uIHRoZSB0ZXh0dXJlIHJlY3Vyc2l2ZWx5IGFuZCBnZXQgdGhlIGV4cGVjdGVkIHJlc3VsdFxuICAgICAgY29uc3QgdGV4dHVyZUVsZW1lbnQgPSByZW5kZXJlci5nZXRJbml0VGV4dHVyZShwYXR0ZXJuQ29uZmlnLmJhY2tncm91bmRDb2xvcilcblxuICAgICAgaWYgKCF0ZXh0dXJlLmRyYXcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0dXJlIGhhcyBubyBwcmUtZGVmaW5lZCBkcmF3IGZ1bmN0aW9uOiAke3RleHR1cmUubmFtZX1gKVxuICAgICAgfVxuXG4gICAgICB0ZXh0dXJlLmRyYXcodGV4dHVyZUVsZW1lbnQsIHJlbmRlcmVyLCB7XG4gICAgICAgIG1vZGU6IHBhdHRlcm5Db25maWcubW9kZSxcbiAgICAgIH0pXG5cbiAgICAgIGZpbGxQYXR0ZXJuU3RhdGUuZmlsbFBhdHRlcm5DYWNoZVtoYXNoS2V5XSA9IHRleHR1cmVFbGVtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGxQYXR0ZXJuU3RhdGUuZmlsbFBhdHRlcm5DYWNoZVtoYXNoS2V5XVxuICB9LFxuXG4gIHRleHR1cmVNb2RlVHlwZToge1xuICAgIExpZ2h0OiBUZXh0dXJlTW9kZVR5cGUuTGlnaHQsXG4gICAgTWVkaXVtOiBUZXh0dXJlTW9kZVR5cGUuTWVkaXVtLFxuICAgIEhlYXZ5OiBUZXh0dXJlTW9kZVR5cGUuSGVhdnksXG4gIH0sXG59XG5cbi8vIE5lZWQgdG8gbG9hZCBhbGwgYnVpbHQtaW4gdGV4dHVyZXNcbnV0aWwubG9hZFRleHR1cmUobmV3IExpbmVUZXh0dXJlKCkpXG5cbmV4cG9ydCBkZWZhdWx0IGZpbGxQYXR0ZXJuXG4iLCJpbXBvcnQgeyBUZXh0dXJlRWxlbWVudCwgSVRleHR1cmUgfSBmcm9tICcuL3R5cGVzJ1xuXG5jb25zdCBmaWxsUGF0dGVybkNhY2hlOiB7W2tleTogc3RyaW5nXTogVGV4dHVyZUVsZW1lbnR9ID0ge31cbmNvbnN0IHRleHR1cmVNYXA6IHtba2V5OiBzdHJpbmddOiBJVGV4dHVyZX0gPSB7fVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGZpbGxQYXR0ZXJuQ2FjaGUsXG4gIHRleHR1cmVNYXAsXG59XG4iLCJpbXBvcnQge1xuICBUZXh0dXJlRWxlbWVudCxcbiAgSVRleHR1cmVDb25maWcsXG4gIElQb3NpdGlvbixcbiAgSURpbWVuc2lvbixcbiAgSVJlbmRlcmVyLFxuICBJUmVuZGVyYWJsZUVsZW1lbnQsXG4gIElTaW1wbGVUZXh0dXJlQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJ1xuXG5jb25zdCBjYW52YXNSZW5kZXJlcjogSVJlbmRlcmVyID0ge1xuICBnZXRJbml0VGV4dHVyZTogKGJhY2tncm91bmRDb2xvcjogc3RyaW5nKTogSFRNTENhbnZhc0VsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FudmFzIDJkIGNvbnRleHQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgIH1cblxuICAgIGNhbnZhcy53aWR0aCA9IDJcbiAgICBjYW52YXMuaGVpZ2h0ID0gMlxuXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3IgfHwgJ3RyYW5zcGFyZW50J1xuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgMiwgMilcblxuICAgIHJldHVybiBjYW52YXNcbiAgfSxcblxuICBkcmF3TGluZVRleHR1cmU6IChjYW52YXNUZXh0dXJlRWxlbWVudDogSFRNTENhbnZhc0VsZW1lbnQsIHRleHR1cmVDb25maWc6IElTaW1wbGVUZXh0dXJlQ29uZmlnKTogdm9pZCA9PiB7XG4gICAgaWYgKCFjYW52YXNUZXh0dXJlRWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjYW52YXMgdGV4dHVyZSBlbGVtZW50IHRvIGRyYXcgdGV4dHVyZSB3aXRoJylcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IHRleHR1cmVDb25maWcuZGlzdGFuY2VcbiAgICBjb25zdCBsaW5lV2lkdGggPSB0ZXh0dXJlQ29uZmlnLnRoaWNrbmVzc1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGV4dHVyZUNvbmZpZy5yb3RhdGlvblxuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0ZXh0dXJlQ29uZmlnLmRpbWVuc2lvbnNcblxuICAgIGlmICghZGltZW5zaW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5lIHRleHR1cmUgcmVxdWlyZXMgZGltZW5zaW9ucyBjb25maWcnKVxuICAgIH1cblxuICAgIGNvbnN0IHdpZHRoID0gZGltZW5zaW9ucy53aWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgLy8gY29uc3QgaXNGaWxsID0gdGV4dHVyZUNvbmZpZy5pc0ZpbGxcbiAgICAvLyBjb25zdCBpc1N0cm9rZSA9IHRleHR1cmVDb25maWcuaXNTdHJva2VcbiAgICBjb25zdCBtaW5ZID0gaGVpZ2h0IC8gMiAtIGRpc3RhbmNlXG4gICAgY29uc3QgbWF4WSA9IGhlaWdodCAvIDIgKyBkaXN0YW5jZVxuICAgIGNvbnN0IG1pblggPSAwLjUgKiAod2lkdGggLSBNYXRoLnNxcnQod2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCkpXG4gICAgY29uc3QgbWF4WCA9IDAuNSAqICh3aWR0aCArIE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSlcbiAgICBjb25zdCBvZmZzZXRYID0gKHRleHR1cmVDb25maWcub2Zmc2V0WCB8fCAwKSAlIHdpZHRoXG4gICAgY29uc3Qgb2Zmc2V0WSA9ICh0ZXh0dXJlQ29uZmlnLm9mZnNldFkgfHwgMCkgJSBoZWlnaHRcbiAgICBjb25zdCB0ZXh0dXJlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjb25zdCB0ZXh0dXJlQ3R4ID0gdGV4dHVyZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICBpZiAoIXRleHR1cmVDdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FudmFzIDJkIGNvbnRleHQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgIH1cblxuICAgIHRleHR1cmVDYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoKVxuICAgIHRleHR1cmVDYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQpXG5cbiAgICAvLyBTdGFydCB0byBkcmF3IGxpbmVzXG4gICAgLy8gaWYgKGlzRmlsbCkge1xuICAgIC8vICAgdGV4dHVyZUN0eC5maWxsU3R5bGUgPSBjb25maWcuY29sb3JcbiAgICAvLyB9XG5cbiAgICAvLyBpZiAoaXNTdHJva2UpIHtcbiAgICAvLyAgIHRleHR1cmVDdHguc3Ryb2tlU3R5bGUgPSBjb25maWcuY29sb3JcbiAgICAvLyB9XG5cbiAgICB0ZXh0dXJlQ3R4LnN0cm9rZVN0eWxlID0gdGV4dHVyZUNvbmZpZy5jb2xvclxuXG4gICAgLy8gUm90YXRlIHRleHR1cmUgY2FudmFzXG4gICAgY2FudmFzUmVuZGVyZXIucm90YXRlKHRleHR1cmVDYW52YXMsIHJvdGF0aW9uKVxuICAgIHRleHR1cmVDdHgubGluZVdpZHRoID0gbGluZVdpZHRoXG4gICAgdGV4dHVyZUN0eC5iZWdpblBhdGgoKVxuXG4gICAgbGV0IHkgPSBtaW5ZXG4gICAgd2hpbGUgKHkgPD0gbWF4WSkge1xuICAgICAgdGV4dHVyZUN0eC5tb3ZlVG8obWluWCArIG9mZnNldFgsIHkgKyBvZmZzZXRZKVxuICAgICAgdGV4dHVyZUN0eC5saW5lVG8obWF4WCArIG9mZnNldFgsIHkgKyBvZmZzZXRZKVxuXG4gICAgICAvLyBUaGUgY2FudmFzIHdpbGwgYmUgcm91bmQgZG93biB0byBmdWxsIHBpeGVsIGRpbWVuc2lvbiwgd2hpbGUgdGhlIGNhbGN1bGF0aW9uXG4gICAgICAvLyBhc3N1bWVzIHdlIGFyZSB1c2luZyB0aGUgb3JpZ2luYWwgbGFyZ2VyIGRpbWVuc2lvbnMgaW4gZnJhY3Rpb24gb2YgYSBwaXhlbC5cbiAgICAgIC8vIFRoaXMgd2lsbCBjb21wZW5zYXRlIHRoYXQuXG4gICAgICB5ICs9IGRpc3RhbmNlIC0gMC4yNVxuICAgIH1cblxuICAgIHRleHR1cmVDdHguc3Ryb2tlKClcblxuICAgIC8vIGlmIChpc1N0cm9rZSkge1xuICAgIC8vICAgdGV4dHVyZUN0eC5zdHJva2UoKVxuICAgIC8vIH1cblxuICAgIC8vIGlmIChpc0ZpbGwpIHtcbiAgICAvLyAgIHRleHR1cmVDdHguZmlsbCgpXG4gICAgLy8gfVxuXG4gICAgY2FudmFzUmVuZGVyZXIuY29tYmluZVRleHR1cmVzKGNhbnZhc1RleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ2FudmFzKVxuICB9LFxuXG4gIHJvdGF0ZTogKGNhbnZhc0VsZW1lbnQ6IEhUTUxDYW52YXNFbGVtZW50LCBhbmdsZTogbnVtYmVyLCBvcmlnaW5Qb3NpdGlvbj86IElQb3NpdGlvbik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJylcblxuICAgIGlmICghY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW52YXMgMmQgY29udGV4dCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gICAgfVxuXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXNFbGVtZW50LndpZHRoXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzRWxlbWVudC5oZWlnaHRcbiAgICBsZXQgb3JpZ2luWCA9IHdpZHRoIC8gMlxuICAgIGxldCBvcmlnaW5ZID0gaGVpZ2h0IC8gMlxuXG4gICAgLy8gUm90YXRlIHRleHR1cmUgY2FudmFzXG4gICAgaWYgKG9yaWdpblBvc2l0aW9uKSB7XG4gICAgICBvcmlnaW5YID0gb3JpZ2luUG9zaXRpb24ueFxuICAgICAgb3JpZ2luWSA9IG9yaWdpblBvc2l0aW9uLnlcbiAgICB9XG5cbiAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmlnaW5YLCBvcmlnaW5ZKVxuICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKVxuICAgIGNvbnRleHQudHJhbnNsYXRlKC1vcmlnaW5YLCAtb3JpZ2luWSlcbiAgfSxcblxuICBjb21iaW5lVGV4dHVyZXM6IChcbiAgICBkZXN0aW5hdGlvbkNhbnZhc1RleHR1cmVFbGVtZW50OiBIVE1MQ2FudmFzRWxlbWVudCwgc291cmNlQ2FudmFzVGV4dHVyZUVsZW1lbnQ6IEhUTUxDYW52YXNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IGRlc3RpbmF0aW9uQ2FudmFzVGV4dHVyZUVsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbnZhcyAyZCBjb250ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgICB9XG5cbiAgICBsZXQgZmluYWxDYW52YXNXaWR0aDogbnVtYmVyID0gZGVzdGluYXRpb25DYW52YXNUZXh0dXJlRWxlbWVudC53aWR0aFxuICAgIGxldCBmaW5hbENhbnZhc0hlaWdodDogbnVtYmVyID0gZGVzdGluYXRpb25DYW52YXNUZXh0dXJlRWxlbWVudC5oZWlnaHRcbiAgICBsZXQgZmluYWxDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4gICAgbGV0IGZpbmFsQ29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIHwgbnVsbFxuXG4gICAgY29udGV4dC5zYXZlKClcbiAgICAvLyBJbiBjYXNlIHdlIGhhdmUgbXVsdGlwbGUgcGF0dGVybnMsIHdlIG5lZWQgdG8gdXNlIGEgdGV4dHVyZSBjYW52YXMgdGhlIHNpemUgb2YgdGhlXG4gICAgLy8gbGVhc3QgY29tbW9uIG11bHRpcGxpZXIgb2Ygd2lkdGggYW5kIGhlaWdodCBvZiBhbGwgb2YgdGhlbVxuICAgIGZpbmFsQ2FudmFzV2lkdGggPSB1dGlsLmxjbShmaW5hbENhbnZhc1dpZHRoLCBzb3VyY2VDYW52YXNUZXh0dXJlRWxlbWVudC53aWR0aClcbiAgICBmaW5hbENhbnZhc0hlaWdodCA9IHV0aWwubGNtKGZpbmFsQ2FudmFzSGVpZ2h0LCBzb3VyY2VDYW52YXNUZXh0dXJlRWxlbWVudC5oZWlnaHQpXG5cbiAgICBpZiAoZmluYWxDYW52YXNXaWR0aCA9PT0gZGVzdGluYXRpb25DYW52YXNUZXh0dXJlRWxlbWVudC53aWR0aCAmJlxuICAgICAgZmluYWxDYW52YXNIZWlnaHQgPT09IGRlc3RpbmF0aW9uQ2FudmFzVGV4dHVyZUVsZW1lbnQuaGVpZ2h0KSB7XG4gICAgICAvLyB0aGUgY2FudmFzIGlzIHN0aWxsIGZpbmUgdG8gdXNlXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihzb3VyY2VDYW52YXNUZXh0dXJlRWxlbWVudCwgJ3JlcGVhdCcpXG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGZpbmFsQ2FudmFzV2lkdGgsIGZpbmFsQ2FudmFzSGVpZ2h0KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgZGltZW5zaW9uIGZvciB0aGUgY2FudmFzXG4gICAgICBmaW5hbENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICBmaW5hbENhbnZhcy53aWR0aCA9IGZpbmFsQ2FudmFzV2lkdGhcbiAgICAgIGZpbmFsQ2FudmFzLmhlaWdodCA9IGZpbmFsQ2FudmFzSGVpZ2h0XG4gICAgICBmaW5hbENvbnRleHQgPSBmaW5hbENhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICAgIGlmICghZmluYWxDb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2FudmFzIDJkIGNvbnRleHQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBmaWxsIHRoZSBvcmlnaW5hbCB0ZXh0dXJlXG4gICAgICBmaW5hbENvbnRleHQuZmlsbFN0eWxlID0gZmluYWxDb250ZXh0LmNyZWF0ZVBhdHRlcm4oZGVzdGluYXRpb25DYW52YXNUZXh0dXJlRWxlbWVudCwgJ3JlcGVhdCcpXG4gICAgICBmaW5hbENvbnRleHQuZmlsbFJlY3QoMCwgMCwgZmluYWxDYW52YXNXaWR0aCwgZmluYWxDYW52YXNIZWlnaHQpXG5cbiAgICAgIC8vIFRoZW4gZmlsbCB0aGUgbmV3IHRleHR1cmVcbiAgICAgIGZpbmFsQ29udGV4dC5maWxsU3R5bGUgPSBmaW5hbENvbnRleHQuY3JlYXRlUGF0dGVybihzb3VyY2VDYW52YXNUZXh0dXJlRWxlbWVudCwgJ3JlcGVhdCcpXG4gICAgICBmaW5hbENvbnRleHQuZmlsbFJlY3QoMCwgMCwgZmluYWxDYW52YXNXaWR0aCwgZmluYWxDYW52YXNIZWlnaHQpXG5cbiAgICAgIC8vIFVwZGF0ZSBjYW52YXMgYW5kIHJlc2V0IGl0IHRvIGZpbmFsIGNhbnZhc1xuICAgICAgZGVzdGluYXRpb25DYW52YXNUZXh0dXJlRWxlbWVudC53aWR0aCA9IGZpbmFsQ2FudmFzV2lkdGhcbiAgICAgIGRlc3RpbmF0aW9uQ2FudmFzVGV4dHVyZUVsZW1lbnQuaGVpZ2h0ID0gZmluYWxDYW52YXNIZWlnaHRcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGZpbmFsQ2FudmFzV2lkdGgsIGZpbmFsQ2FudmFzSGVpZ2h0KVxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoZmluYWxDYW52YXMsIDAsIDApXG4gICAgfVxuICAgIGNvbnRleHQucmVzdG9yZSgpXG4gIH0sXG5cbiAgLy8gVE9ETzogSW4gU1ZHIGNhc2UsIHRoZSBzb3VyY2UgdGV4dHVyZSBpcyBhY3R1YWxseSBqdXN0IGEgc3ZnIHBhdHRlcm4gZWxlbWVudFxuICAvLyAvLyBXZSBuZWVkIHRvIG1ha2Ugc29tZSBjaGFuZ2VzIGhlcmUgdG8gZ2V0IHRoaXMgcGFydCB3b3JraW5nXG4gIGdldERhdGFVUkw6IChjYW52YXNUZXh0dXJlRWxlbWVudDogSFRNTENhbnZhc0VsZW1lbnQpOiBzdHJpbmcgPT4gY2FudmFzVGV4dHVyZUVsZW1lbnQudG9EYXRhVVJMKCksXG5cbiAgZ2V0VGV4dHVyZVNpemU6IChjYW52YXNUZXh0dXJlRWxlbWVudDogSFRNTENhbnZhc0VsZW1lbnQpOiBJRGltZW5zaW9uID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGNhbnZhc1RleHR1cmVFbGVtZW50LndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXNUZXh0dXJlRWxlbWVudC5oZWlnaHQsXG4gICAgfVxuICB9LFxuXG4gIC8vIC8vIFJlbmRlcmluZyByZWxhdGVkIGFwaVxuICAvLyBkcmF3Q2lyY2xlVGV4dHVyZTogKHRleHR1cmVFbGVtZW50OiBUZXh0dXJlRWxlbWVudCwgdGV4dHVyZUNvbmZpZzogSVRleHR1cmVDb25maWcpID0+IHZvaWRcbiAgLy8gZHJhd1NxdWFyZVRleHR1cmU6ICh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHRleHR1cmVDb25maWc6IElUZXh0dXJlQ29uZmlnKSA9PiB2b2lkXG4gIC8vIGRyYXdEaXNhYmxlZFRleHR1cmU6ICh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHRleHR1cmVDb25maWc6IElUZXh0dXJlQ29uZmlnKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhbnZhc1JlbmRlcmVyXG4iLCJpbXBvcnQge1xuICBUZXh0dXJlRWxlbWVudCxcbiAgSVJlbmRlcmVyLFxuICBJRHJhd0NvbmZpZyxcbiAgSVRleHR1cmVDb25maWcsXG4gIFRleHR1cmVNb2RlVHlwZSxcbiAgSVRleHR1cmUsXG4gIENvbXBsZXhUZXh0dXJlQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmltcG9ydCBmaWxsUGF0dGVyblN0YXRlIGZyb20gJy4uL2ZpbGxQYXR0ZXJuU3RhdGUnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VUZXh0dXJlIGltcGxlbWVudHMgSVRleHR1cmUge1xuICBwdWJsaWMgbmFtZTogc3RyaW5nID0gJ2Jhc2VUZXh0dXJlJ1xuXG4gIHB1YmxpYyBtb2RlOiB7W2tleTogc3RyaW5nXTogSVRleHR1cmVDb25maWd9ID0ge1xuICAgIC8vIFRPRE86IEhvdyB0byB1c2UgZW51bXMgZm9yIHRoZSBkZWZhdWx0IHRleHR1cmUgY29uZmlnIG5hbWU/XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgZGlzdGFuY2U6IDMsXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMCxcbiAgICB9LFxuICB9XG5cbiAgY29uc3RydWN0b3IodGV4dHVyZU9wdGlvbnM/OiBJVGV4dHVyZSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgdGV4dHVyZU9wdGlvbnMpXG4gIH1cblxuICBwdWJsaWMgZHJhdyh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHJlbmRlcmVyOiBJUmVuZGVyZXIsIGRyYXdDb25maWc6IElEcmF3Q29uZmlnKSB7XG4gICAgY29uc3QgeyBtb2RlLCBjb25maWcgfSA9IGRyYXdDb25maWdcbiAgICBsZXQgdGV4dHVyZUNvbmZpZ3M6IElUZXh0dXJlQ29uZmlnID0gdGhpcy5tb2RlW21vZGUgfHwgVGV4dHVyZU1vZGVUeXBlLkRlZmF1bHRdXG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGV4dHVyZUNvbmZpZ3MpKSB7XG4gICAgICB0ZXh0dXJlQ29uZmlncyA9IFt0ZXh0dXJlQ29uZmlnc11cbiAgICB9XG5cbiAgICB0ZXh0dXJlQ29uZmlncy5mb3JFYWNoKChjb25maWdEZXRhaWxzKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLmRldGFpbENvbmZpZ3MgfSA9IGNvbmZpZ0RldGFpbHNcblxuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIFRoZSBwYXR0ZXJuIG1vZGUgY29uZmlncyBtYXkgY29udGFpbiBhbnkgZmlsbCBwYXR0ZXJuIGFzIGl0cyBjaGlsZHJlblxuICAgICAgICAvLyBsYXllcnMuIElmIGl0IGRvZXMgc28sIGl0IG5lZWQgdG8gaW5jbHVkZSB0aGUgcGF0dGVybiBuYW1lIGluIHRoZSBjb25maWdcbiAgICAgICAgLy8gZGV0YWlscy4gRm9yIGJhc2ljIGZpbGwgcGF0dGVybnMgbGlrZSBsaW5lLCBjaXJjbGUgb3Igc3F1YXJlLCB0aGV5IG5lZWRcbiAgICAgICAgLy8gdG8gb3ZlcnJpZGUgZHJhdyBmdW5jdGlvbiB0byBkcmF3IGJ5IHRoZW1zZWx2ZXMsIGhlbmNlIGl0IHNob3VsZCBuZXZlclxuICAgICAgICAvLyBoaXQgdGhpcyBjb25kaXRpb24gaGVyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEbyBub3Qga25vdyBob3cgdG8gZHJhdyB0aGlzIGNvbmZpZzogJHtuYW1lfWApXG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb25maWcgaGFzIGEgcGF0dGVybiBuYW1lLCB3aGljaCBtZWFucyBpdCdzIGNvbXBvc2VkIGJ5XG4gICAgICAvLyBvdGhlciBwYXR0ZXJuc1xuICAgICAgY29uc3QgY2hpbGRUZXh0dXJlID0gZmlsbFBhdHRlcm5TdGF0ZS50ZXh0dXJlTWFwW25hbWVdXG5cbiAgICAgIGlmICghY2hpbGRUZXh0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCB0ZXh0dXJlIGV4aXN0OiAke25hbWV9YClcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZFRleHR1cmUuZHJhdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkcmF3IHRleHR1cmU6ICR7bmFtZX1gKVxuICAgICAgfVxuXG4gICAgICBjaGlsZFRleHR1cmUuZHJhdyh0ZXh0dXJlRWxlbWVudCwgcmVuZGVyZXIsIHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgLy8gV2UgZ290IHNvbWUgcHJvYmxlbSBoZXJlXG4gICAgICAgIC8vIFNob3VsZCB0aGUgY29uZmlnIHBhc3MgZG93biB0byB0aGUgZ3JhbmQgY2hpbGRyZW4/XG4gICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlsQ29uZmlncywgY29uZmlnKSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgSURpbWVuc2lvbixcbiAgSVRleHR1cmUsXG4gIFRleHR1cmVNb2RlVHlwZSxcbiAgVGV4dHVyZUVsZW1lbnQsXG4gIElSZW5kZXJlcixcbiAgSURyYXdDb25maWcsXG4gIElTaW1wbGVUZXh0dXJlQ29uZmlnLFxuICBJVGV4dHVyZUNvbmZpZ30gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgQmFzZVRleHR1cmUgZnJvbSAnLi9iYXNlJ1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCdcblxuY29uc3QgREVGQVVMVF9QQVRURVJOX1NJWkU6IG51bWJlciA9IDEwXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURpbWVuc2lvbnMoZGlzdGFuY2U6IG51bWJlciwgcm90YXRpb246IG51bWJlcik6IElEaW1lbnNpb24ge1xuICBsZXQgd2lkdGg6IG51bWJlclxuICBsZXQgaGVpZ2h0OiBudW1iZXJcblxuICByb3RhdGlvbiA9IHJvdGF0aW9uICUgTWF0aC5QSVxuXG4gIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgIHdpZHRoID0gREVGQVVMVF9QQVRURVJOX1NJWkVcbiAgICBoZWlnaHQgPSBkaXN0YW5jZVxuICB9IGVsc2UgaWYgKHJvdGF0aW9uID09PSBNYXRoLlBJICogMC41KSB7XG4gICAgd2lkdGggPSBkaXN0YW5jZVxuICAgIGhlaWdodCA9IERFRkFVTFRfUEFUVEVSTl9TSVpFXG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBkaXN0YW5jZSAvIE1hdGguc2luKHJvdGF0aW9uKVxuICAgIGhlaWdodCA9IGRpc3RhbmNlIC8gTWF0aC5hYnMoTWF0aC5jb3Mocm90YXRpb24pKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gIH1cbn1cblxuY29uc3QgbGlnaHRNb2RlVGV4dHVyZTogSVNpbXBsZVRleHR1cmVDb25maWcgPSB7XG4gIGNvbG9yOiAnIzAwMDAwMCcsXG4gIGRpc3RhbmNlOiA0LFxuICByb3RhdGlvbjogMCxcbiAgdGhpY2tuZXNzOiAxLFxufVxuXG5jb25zdCBtZWRpdW1Nb2RlVGV4dHVyZTogSVNpbXBsZVRleHR1cmVDb25maWcgPSB7XG4gIGNvbG9yOiAnIzAwMDAwMCcsXG4gIGRpc3RhbmNlOiA0LFxuICByb3RhdGlvbjogMCxcbiAgdGhpY2tuZXNzOiAyLFxufVxuXG5jb25zdCBoZWF2eU1vZGVUZXh0dXJlOiBJU2ltcGxlVGV4dHVyZUNvbmZpZyA9IHtcbiAgY29sb3I6ICcjMDAwMDAwJyxcbiAgZGlzdGFuY2U6IDQsXG4gIHJvdGF0aW9uOiAwLFxuICB0aGlja25lc3M6IDMsXG59XG5cbmNsYXNzIExpbmVUZXh0dXJlIGV4dGVuZHMgQmFzZVRleHR1cmUgaW1wbGVtZW50cyBJVGV4dHVyZSB7XG4gIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSAnbGluZSdcblxuICBwdWJsaWMgbW9kZToge1trZXk6IHN0cmluZ106IElTaW1wbGVUZXh0dXJlQ29uZmlnfSA9IHtcbiAgICAvLyBUT0RPOiBIb3cgdG8gdXNlIGVudW1zIGZvciB0aGUgZGVmYXVsdCB0ZXh0dXJlIGNvbmZpZyBuYW1lP1xuICAgIGRlZmF1bHQ6IG1lZGl1bU1vZGVUZXh0dXJlLFxuICAgIGxpZ2h0OiBsaWdodE1vZGVUZXh0dXJlLFxuICAgIG1lZGl1bTogbWVkaXVtTW9kZVRleHR1cmUsXG4gICAgaGVhdnk6IGhlYXZ5TW9kZVRleHR1cmUsXG4gIH1cblxuICBwdWJsaWMgZHJhdyh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHJlbmRlcmVyOiBJUmVuZGVyZXIsIGRyYXdDb25maWc6IElEcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge21vZGUsIGNvbmZpZ30gPSBkcmF3Q29uZmlnXG5cbiAgICBjb25zdCB0ZXh0dXJlQ29uZmlnOiBJU2ltcGxlVGV4dHVyZUNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sXG4gICAgICAvLyBUT0RPOiBkZWZhdWx0IHRvIHRoZSBtZWRpdW0gbW9kZSwgYnV0IGl0IHNob3VsZCByZWFsbHkgYmUgc29tZSBmYWxsYmFjayBtb2RlXG4gICAgICB0aGlzLm1vZGVbbW9kZSB8fCBUZXh0dXJlTW9kZVR5cGUuTWVkaXVtXSxcbiAgICAgIGNvbmZpZylcblxuICAgIHRleHR1cmVDb25maWcuZGltZW5zaW9ucyA9IHRleHR1cmVDb25maWcuZGltZW5zaW9ucyB8fFxuICAgICAgY2FsY3VsYXRlRGltZW5zaW9ucyh0ZXh0dXJlQ29uZmlnLmRpc3RhbmNlLCB0ZXh0dXJlQ29uZmlnLnJvdGF0aW9uKVxuXG4gICAgcmVuZGVyZXIuZHJhd0xpbmVUZXh0dXJlKHRleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ29uZmlnKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmVUZXh0dXJlXG4iLCJpbXBvcnQge1xuICBUZXh0dXJlRWxlbWVudCxcbiAgSVJlbmRlcmVyLFxuICBJRHJhd0NvbmZpZyxcbiAgSVRleHR1cmVDb25maWcsXG4gIFRleHR1cmVNb2RlVHlwZSxcbiAgSVRleHR1cmUsXG4gIENvbXBsZXhUZXh0dXJlQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmltcG9ydCBmaWxsUGF0dGVyblN0YXRlIGZyb20gJy4uL2ZpbGxQYXR0ZXJuU3RhdGUnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VUZXh0dXJlIGltcGxlbWVudHMgSVRleHR1cmUge1xuICBwdWJsaWMgbmFtZTogc3RyaW5nID0gJ2Jhc2VUZXh0dXJlJ1xuXG4gIHB1YmxpYyBtb2RlOiB7W2tleTogc3RyaW5nXTogSVRleHR1cmVDb25maWd9ID0ge1xuICAgIC8vIFRPRE86IEhvdyB0byB1c2UgZW51bXMgZm9yIHRoZSBkZWZhdWx0IHRleHR1cmUgY29uZmlnIG5hbWU/XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgZGlzdGFuY2U6IDMsXG4gICAgICByb3RhdGlvbjogMCxcbiAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMCxcbiAgICB9LFxuICB9XG5cbiAgY29uc3RydWN0b3IodGV4dHVyZU9wdGlvbnM/OiBJVGV4dHVyZSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgdGV4dHVyZU9wdGlvbnMpXG4gIH1cblxuICBwdWJsaWMgZHJhdyh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHJlbmRlcmVyOiBJUmVuZGVyZXIsIGRyYXdDb25maWc6IElEcmF3Q29uZmlnKSB7XG4gICAgY29uc3QgeyBtb2RlLCBjb25maWcgfSA9IGRyYXdDb25maWdcbiAgICBsZXQgdGV4dHVyZUNvbmZpZ3M6IElUZXh0dXJlQ29uZmlnID0gdGhpcy5tb2RlW21vZGUgfHwgVGV4dHVyZU1vZGVUeXBlLkRlZmF1bHRdXG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGV4dHVyZUNvbmZpZ3MpKSB7XG4gICAgICB0ZXh0dXJlQ29uZmlncyA9IFt0ZXh0dXJlQ29uZmlnc11cbiAgICB9XG5cbiAgICB0ZXh0dXJlQ29uZmlncy5mb3JFYWNoKChjb25maWdEZXRhaWxzKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLmRldGFpbENvbmZpZ3MgfSA9IGNvbmZpZ0RldGFpbHNcblxuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIFRoZSBwYXR0ZXJuIG1vZGUgY29uZmlncyBtYXkgY29udGFpbiBhbnkgZmlsbCBwYXR0ZXJuIGFzIGl0cyBjaGlsZHJlblxuICAgICAgICAvLyBsYXllcnMuIElmIGl0IGRvZXMgc28sIGl0IG5lZWQgdG8gaW5jbHVkZSB0aGUgcGF0dGVybiBuYW1lIGluIHRoZSBjb25maWdcbiAgICAgICAgLy8gZGV0YWlscy4gRm9yIGJhc2ljIGZpbGwgcGF0dGVybnMgbGlrZSBsaW5lLCBjaXJjbGUgb3Igc3F1YXJlLCB0aGV5IG5lZWRcbiAgICAgICAgLy8gdG8gb3ZlcnJpZGUgZHJhdyBmdW5jdGlvbiB0byBkcmF3IGJ5IHRoZW1zZWx2ZXMsIGhlbmNlIGl0IHNob3VsZCBuZXZlclxuICAgICAgICAvLyBoaXQgdGhpcyBjb25kaXRpb24gaGVyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEbyBub3Qga25vdyBob3cgdG8gZHJhdyB0aGlzIGNvbmZpZzogJHtuYW1lfWApXG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb25maWcgaGFzIGEgcGF0dGVybiBuYW1lLCB3aGljaCBtZWFucyBpdCdzIGNvbXBvc2VkIGJ5XG4gICAgICAvLyBvdGhlciBwYXR0ZXJuc1xuICAgICAgY29uc3QgY2hpbGRUZXh0dXJlID0gZmlsbFBhdHRlcm5TdGF0ZS50ZXh0dXJlTWFwW25hbWVdXG5cbiAgICAgIGlmICghY2hpbGRUZXh0dXJlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCB0ZXh0dXJlIGV4aXN0OiAke25hbWV9YClcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGlsZFRleHR1cmUuZHJhdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkcmF3IHRleHR1cmU6ICR7bmFtZX1gKVxuICAgICAgfVxuXG4gICAgICBjaGlsZFRleHR1cmUuZHJhdyh0ZXh0dXJlRWxlbWVudCwgcmVuZGVyZXIsIHtcbiAgICAgICAgbW9kZSxcbiAgICAgICAgLy8gV2UgZ290IHNvbWUgcHJvYmxlbSBoZXJlXG4gICAgICAgIC8vIFNob3VsZCB0aGUgY29uZmlnIHBhc3MgZG93biB0byB0aGUgZ3JhbmQgY2hpbGRyZW4/XG4gICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlsQ29uZmlncywgY29uZmlnKSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiZXhwb3J0IHR5cGUgVGV4dHVyZUVsZW1lbnQgPSBIVE1MQ2FudmFzRWxlbWVudCB8IFNWR0RlZnNFbGVtZW50XG5leHBvcnQgdHlwZSBJUmVuZGVyYWJsZUVsZW1lbnQgPSBIVE1MQ2FudmFzRWxlbWVudCB8IFNWR0VsZW1lbnRcblxuZXhwb3J0IGludGVyZmFjZSBJRGltZW5zaW9uIHtcbiAgd2lkdGg6IG51bWJlclxuICBoZWlnaHQ6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElQb3NpdGlvbiB7XG4gIHg6IG51bWJlclxuICB5OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmVuZGVyZXIge1xuICBnZXRJbml0VGV4dHVyZTogKGJhY2tncm91bmRDb2xvcjogc3RyaW5nKSA9PiBUZXh0dXJlRWxlbWVudFxuICAvLyBUT0RPOiBJbiBTVkcgY2FzZSwgdGhlIHNvdXJjZSB0ZXh0dXJlIGlzIGFjdHVhbGx5IGp1c3QgYSBzdmcgcGF0dGVybiBlbGVtZW50XG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzb21lIGNoYW5nZXMgaGVyZSB0byBnZXQgdGhpcyBwYXJ0IHdvcmtpbmdcbiAgY29tYmluZVRleHR1cmVzOiAoZGVzdGluYXRpb25UZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHNvdXJjZVRleHR1cmVFbGVtZW50OiBUZXh0dXJlRWxlbWVudCkgPT4gdm9pZFxuICBnZXREYXRhVVJMOiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50KSA9PiBzdHJpbmdcbiAgZ2V0VGV4dHVyZVNpemU6ICh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQpID0+IElEaW1lbnNpb25cbiAgLy8gUmVuZGVyaW5nIHJlbGF0ZWQgYXBpXG4gIC8vIGRyYXdDaXJjbGVUZXh0dXJlOiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ29uZmlnOiBJVGV4dHVyZUNvbmZpZykgPT4gdm9pZFxuICBkcmF3TGluZVRleHR1cmU6ICh0ZXh0dXJlRWxlbWVudDogVGV4dHVyZUVsZW1lbnQsIHRleHR1cmVDb25maWc6IElUZXh0dXJlQ29uZmlnKSA9PiB2b2lkXG4gIC8vIGRyYXdTcXVhcmVUZXh0dXJlOiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ29uZmlnOiBJVGV4dHVyZUNvbmZpZykgPT4gdm9pZFxuICAvLyBkcmF3RGlzYWJsZWRUZXh0dXJlOiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ29uZmlnOiBJVGV4dHVyZUNvbmZpZykgPT4gdm9pZFxuICByb3RhdGU6IChlbGVtZW50OiBJUmVuZGVyYWJsZUVsZW1lbnQsIGFuZ2xlOiBudW1iZXIsIG9yaWdpblBvc2l0aW9uPzogSVBvc2l0aW9uKSA9PiB2b2lkXG59XG5cbi8vIGV4cG9ydCBpbnRlcmZhY2UgSVJlbmRlcmVyPFQgZXh0ZW5kcyBUZXh0dXJlRWxlbWVudCwgUyBleHRlbmRzIElSZW5kZXJhYmxlRWxlbWVudD4ge1xuLy8gICBnZXRJbml0VGV4dHVyZTogKGJhY2tncm91bmRDb2xvcjogc3RyaW5nKSA9PiBUXG4vLyAgIC8vIFRPRE86IEluIFNWRyBjYXNlLCB0aGUgc291cmNlIHRleHR1cmUgaXMgYWN0dWFsbHkganVzdCBhIHN2ZyBwYXR0ZXJuIGVsZW1lbnRcbi8vICAgLy8gV2UgbmVlZCB0byBtYWtlIHNvbWUgY2hhbmdlcyBoZXJlIHRvIGdldCB0aGlzIHBhcnQgd29ya2luZ1xuLy8gICBjb21iaW5lVGV4dHVyZXM6IChkZXN0aW5hdGlvblRleHR1cmVFbGVtZW50OiBULCBzb3VyY2VUZXh0dXJlRWxlbWVudDogVCkgPT4gdm9pZFxuLy8gICBnZXREYXRhVVJMOiAodGV4dHVyZUVsZW1lbnQ6IFQpID0+IHN0cmluZ1xuLy8gICBnZXRUZXh0dXJlU2l6ZTogKHRleHR1cmVFbGVtZW50OiBUKSA9PiBJRGltZW5zaW9uXG4vLyAgIC8vIFJlbmRlcmluZyByZWxhdGVkIGFwaVxuLy8gICAvLyBkcmF3Q2lyY2xlVGV4dHVyZTogKHRleHR1cmVFbGVtZW50OiBUZXh0dXJlRWxlbWVudCwgdGV4dHVyZUNvbmZpZzogSVRleHR1cmVDb25maWcpID0+IHZvaWRcbi8vICAgZHJhd0xpbmVUZXh0dXJlOiAodGV4dHVyZUVsZW1lbnQ6IFQsIHRleHR1cmVDb25maWc6IElUZXh0dXJlQ29uZmlnKSA9PiB2b2lkXG4vLyAgIC8vIGRyYXdTcXVhcmVUZXh0dXJlOiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ29uZmlnOiBJVGV4dHVyZUNvbmZpZykgPT4gdm9pZFxuLy8gICAvLyBkcmF3RGlzYWJsZWRUZXh0dXJlOiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50LCB0ZXh0dXJlQ29uZmlnOiBJVGV4dHVyZUNvbmZpZykgPT4gdm9pZFxuLy8gICByb3RhdGU6IChlbGVtZW50OiBTLCBhbmdsZTogbnVtYmVyLCBvcmlnaW5Qb3NpdGlvbj86IElQb3NpdGlvbikgPT4gdm9pZFxuLy8gfVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmF3Q29uZmlnIHtcbiAgbW9kZT86IHN0cmluZyB8IFRleHR1cmVNb2RlVHlwZSxcbiAgY29uZmlnPzogSVRleHR1cmVDb25maWdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGV4dHVyZSB7XG4gIG1vZGU6IHtba2V5OiBzdHJpbmddOiBJVGV4dHVyZUNvbmZpZ31cbiAgbmFtZTogc3RyaW5nXG4gIGRyYXc/OiAodGV4dHVyZUVsZW1lbnQ6IFRleHR1cmVFbGVtZW50LCByZW5kZXJlcjogSVJlbmRlcmVyLCBjb25maWc6IElEcmF3Q29uZmlnKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBhdHRlcm5Db25maWcge1xuICBuYW1lOiBzdHJpbmdcbiAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmdcbiAgbW9kZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNpbXBsZVRleHR1cmVDb25maWcge1xuICBuYW1lPzogc3RyaW5nXG4gIHRoaWNrbmVzczogbnVtYmVyXG4gIGRpc3RhbmNlOiBudW1iZXJcbiAgcm90YXRpb246IG51bWJlclxuICBjb2xvcjogc3RyaW5nXG4gIGRpbWVuc2lvbnM/OiBJRGltZW5zaW9uXG4gIG9mZnNldFg/OiBudW1iZXJcbiAgb2Zmc2V0WT86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBDb21wbGV4VGV4dHVyZUNvbmZpZyA9IElTaW1wbGVUZXh0dXJlQ29uZmlnW11cblxuZXhwb3J0IHR5cGUgSVRleHR1cmVDb25maWcgPSBJU2ltcGxlVGV4dHVyZUNvbmZpZyB8IENvbXBsZXhUZXh0dXJlQ29uZmlnXG5cbi8qKioqKiBFbnVtcyAqKioqKi9cbmV4cG9ydCBlbnVtIFJlbmRlcmVyVHlwZSB7XG4gIENhbnZhcyxcbiAgU1ZHLFxufVxuXG5leHBvcnQgZW51bSBUZXh0dXJlTW9kZVR5cGUge1xuICBMaWdodCxcbiAgTWVkaXVtLFxuICBIZWF2eSxcbiAgRGVmYXVsdCxcbn1cbiIsImltcG9ydCB7IElUZXh0dXJlIH0gZnJvbSAnLi90eXBlcydcbmltcG9ydCBmaWxsUGF0dGVyblN0YXRlIGZyb20gJy4vZmlsbFBhdHRlcm5TdGF0ZSdcbmltcG9ydCBCYXNlVGV4dHVyZSBmcm9tICcuL3RleHR1cmVzL0Jhc2UnXG5cbmNvbnN0IGdjZENhY2hlOiB7W2tleTogc3RyaW5nXTogbnVtYmVyfSA9IHt9XG5cbmNvbnN0IHV0aWwgPSB7XG4gIGdjZDogKG51bWJlcjE6IG51bWJlciwgbnVtYmVyMjogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICBpZiAodHlwZW9mIG51bWJlcjEgIT09ICdudW1iZXInIHx8IHR5cGVvZiBudW1iZXIyICE9PSAnbnVtYmVyJyB8fFxuICAgIChOdW1iZXIuaXNOYU4gfHwgaXNOYU4pKG51bWJlcjEpIHx8IChOdW1iZXIuaXNOYU4gfHwgaXNOYU4pKG51bWJlcjIpIHx8XG4gICAgbnVtYmVyMSA8PSAwIHx8IG51bWJlcjIgPD0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgY29uc3Qga2V5MSA9IG51bWJlcjEgKyAnLScgKyBudW1iZXIyXG4gICAgY29uc3Qga2V5MiA9IG51bWJlcjIgKyAnLScgKyBudW1iZXIxXG5cbiAgICBpZiAoZ2NkQ2FjaGVba2V5MV0pIHtcbiAgICAgIHJldHVybiBnY2RDYWNoZVtrZXkxXVxuICAgIH1cblxuICAgIGlmIChudW1iZXIxICE9PSBudW1iZXIyKSB7XG4gICAgICBpZiAobnVtYmVyMSA+IG51bWJlcjIpIHtcbiAgICAgICAgbnVtYmVyMSA9IG51bWJlcjEgLSBudW1iZXIyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1iZXIyID0gbnVtYmVyMiAtIG51bWJlcjFcbiAgICAgIH1cblxuICAgICAgZ2NkQ2FjaGVba2V5MV0gPSB1dGlsLmdjZChudW1iZXIxLCBudW1iZXIyKVxuICAgICAgZ2NkQ2FjaGVba2V5Ml0gPSBnY2RDYWNoZVtrZXkxXVxuICAgICAgcmV0dXJuIGdjZENhY2hlW2tleTFdXG4gICAgfSBlbHNlIHtcbiAgICAgIGdjZENhY2hlW2tleTFdID0gbnVtYmVyMVxuICAgICAgcmV0dXJuIG51bWJlcjFcbiAgICB9XG4gIH0sXG5cbiAgbGNtOiAobnVtYmVyMTogbnVtYmVyLCBudW1iZXIyOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyMSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIG51bWJlcjIgIT09ICdudW1iZXInIHx8XG4gICAgKE51bWJlci5pc05hTiB8fCBpc05hTikobnVtYmVyMSkgfHwgKE51bWJlci5pc05hTiB8fCBpc05hTikobnVtYmVyMikgfHxcbiAgICBudW1iZXIxIDw9IDAgfHwgbnVtYmVyMiA8PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtYmVyMSAqIG51bWJlcjIgLyB1dGlsLmdjZChudW1iZXIxLCBudW1iZXIyKVxuICB9LFxuXG4gIG1peGluOiAoZGVzdGluYXRpb25PYmo6IHtba2V5OiBzdHJpbmddOiBhbnl9LCBzb3VyY2VPYmo6IHtba2V5OiBzdHJpbmddOiBhbnl9KTogdm9pZCA9PiB7XG4gICAgbGV0IGtleTogc3RyaW5nXG4gICAgZm9yIChrZXkgaW4gc291cmNlT2JqKSB7XG4gICAgICBpZiAoc291cmNlT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25PYmpba2V5XSA9IHNvdXJjZU9ialtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3I6IGFueSwgYmFzZUN0b3JzOiBhbnlbXSkge1xuICAgIGJhc2VDdG9ycy5mb3JFYWNoKChiYXNlQ3RvcikgPT4ge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYmFzZUN0b3IucHJvdG90eXBlKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgZGVyaXZlZEN0b3IucHJvdG90eXBlW25hbWVdID0gYmFzZUN0b3IucHJvdG90eXBlW25hbWVdXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG5cbiAgbG9hZFRleHR1cmU6ICh0ZXh0dXJlOiBJVGV4dHVyZSk6IHZvaWQgPT4ge1xuICAgIGlmICghZmlsbFBhdHRlcm5TdGF0ZS50ZXh0dXJlTWFwW3RleHR1cmUubmFtZV0pIHtcbiAgICAgIC8vIHV0aWwuYXBwbHlNaXhpbnModGV4dHVyZSwgW0Jhc2VUZXh0dXJlXSlcbiAgICAgIC8vIHV0aWwubWl4aW4odGV4dHVyZSwgbmV3IEJhc2VUZXh0dXJlKCkpXG5cbiAgICAgIGZpbGxQYXR0ZXJuU3RhdGUudGV4dHVyZU1hcFt0ZXh0dXJlLm5hbWVdID0gdGV4dHVyZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZWQgdGV4dHVyZSBuYW1lOiAke3RleHR1cmUubmFtZX1gKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgdXRpbFxuIl0sInNvdXJjZVJvb3QiOiIifQ==